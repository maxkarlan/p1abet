<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Font Preview with Multiple Text Boxes</title>
    <style>
        @font-face {
            font-family: 'CustomFont';
            src: url('p1a.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        body, html {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100%;
            background-color: #f0f0f0;
        }
        .container {
            display: flex;
            height: 90%;
        }

        .input-column, .settings-column {
            width: 25%;
            padding: 20px;
            background-color: white;
            box-shadow: 0 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
        }

        .preview-column {
            width: 50%;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .preview-wrapper {
            width: 90%;
            padding-bottom: 90%;
            position: relative;
        }
        .preview {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 1px solid #ddd;
            border-radius: 10px;
            font-family: 'CustomFont', sans-serif;
            background-color: white;
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }
        .preview-text {
            position: absolute;
            cursor: move;
            user-select: none;
            transform-origin: center center;
        }
        .preview-text-container {
            position: absolute;
            width: 100%;
            height: 100%;
            cursor: move;
        }
        .shape-select-container {
            margin-bottom: 15px;
        }

        #shapeSelect {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f0f0f0;
            cursor: pointer;
        }

        #shapeSelect:focus {
            outline: none;
            border-color: #007bff;
        }
        .shape-options-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        .shape-select-container, .format-options-container {
            width: 48%;
        }
        #shapeSelect, #formatOptions {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f0f0f0;
            cursor: pointer;
        }
        #shapeSelect:focus, #formatOptions:focus {
            outline: none;
            border-color: #007bff;
        }
        .triangle-text {
            text-align: center;
            display: inline-block;
            line-height: 1.2;
        }
        .background-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .background-option {
            width: 100%;
            padding-top: 100%;
            background-size: cover;
            background-position: center;
            cursor: pointer;
            border: 2px solid #ddd;
            border-radius: 8px;
            transition: border-color 0.3s ease;
        }
        .background-option:hover {
            border-color: #aaa;
        }
        .background-option.active {
            border-color: #007bff;
            box-shadow: 0 0 0 2px #007bff;
        }
        .slider-container {
            margin-top: 15px;
        }
        .size-slider, .rotation-dial {
            width: 100%;
        }
        .text-box-controls {
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
        }
        .text-box-controls button {
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .text-box-controls button:hover {
            background-color: #0056b3;
        }
        .text-box-settings {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            position: relative;
        }
        .text-box-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .visibility-toggle {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            margin-right: 10px;
            width: 24px;
            height: 24px;
        }
        .visibility-toggle img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .remove-text-box {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #ff4d4d;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            line-height: 1;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .text-box-content {
            display: flex;
            flex-direction: column;
        }
        .text-box-content textarea {
            width: 100%;
            margin-bottom: 10px;
        }
        .remove-text-box:hover {
            background-color: #ff1a1a;
        }
        .lightbox {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .lightbox-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 300px;
            text-align: center;
            border-radius: 5px;
        }
        .lightbox-buttons {
            margin-top: 20px;
        }
        .lightbox-buttons button {
            margin: 0 10px;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .confirm-remove {
            background-color: #ff4d4d;
            color: white;
        }
        .cancel-remove {
            background-color: #ddd;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="input-column">
            <h2 class="card-title">Text Boxes</h2>
            <div id="textBoxes"></div>
            <div class="text-box-controls">
                <button id="addTextBox">Add Text Box</button>
            </div>
        </div>
    
        <div class="preview-column">
            <h2 class="card-title">Custom Font Preview</h2>
            <div class="preview-wrapper">
                <div id="preview" class="preview"></div>
            </div>
            <div id="fontStatus"></div>
        </div>
    
        <div class="settings-column">
            <h2 class="card-title">Settings</h2>
            <h3>Background Image</h3>
            <div class="background-grid">
                <div class="background-option" style="background-image: url('images/bg1.png');" data-image="images/bg1.png"></div>
                <div class="background-option" style="background-image: url('images/bg2.png');" data-image="images/bg2.png"></div>
                <div class="background-option" style="background-image: url('images/bg3.png');" data-image="images/bg3.png"></div>
                <div class="background-option" style="background-image: url('images/bg4.png');" data-image="images/bg4.png"></div>
                <div class="background-option" style="background-image: url('images/bg5.png');" data-image="images/bg5.png"></div>
                <div class="background-option" style="background-image: url('images/bg6.png');" data-image="images/bg6.png"></div>
                <div class="background-option" style="background-image: url('images/bg7.png');" data-image="images/bg7.png"></div>
                <div class="background-option" style="background-image: url('images/bg8.png');" data-image="images/bg8.png"></div>
                <div class="background-option" style="background-image: url('images/bg9.png');" data-image="images/bg9.png"></div>
                <div class="background-option" style="background-image: url('images/bg10.png');" data-image="images/bg10.png"></div>
                <div class="background-option" style="background-image: url('images/bg11.png');" data-image="images/bg11.png"></div>
            </div>
        </div>
    </div>

    <div id="removeLightbox" class="lightbox">
        <div class="lightbox-content">
            <p>Are you sure you want to remove this text box?</p>
            <div class="lightbox-buttons">
                <button class="confirm-remove">Confirm</button>
                <button class="cancel-remove">Cancel</button>
            </div>
        </div>
    </div>

    <script>
         let currentBackgroundImage = '';
        const imageCache = new Map();
        let textBoxes = [];

        const preview = document.getElementById('preview');
        const backgroundOptions = document.querySelectorAll('.background-option');
        const addTextBoxButton = document.getElementById('addTextBox');
        const textBoxesContainer = document.getElementById('textBoxes');
        const removeLightbox = document.getElementById('removeLightbox');
        let textBoxToRemove = null;

        function loadCustomFont() {
            const font = new FontFace('CustomFont', 'url(p1a.ttf)');
            const fontStatus = document.getElementById('fontStatus');

            font.load().then(function(loadedFont) {
                document.fonts.add(loadedFont);
                preview.style.fontFamily = 'CustomFont, sans-serif';
                fontStatus.textContent = 'Custom font loaded successfully!';
                updateAllTextBoxes();
            }).catch(function(error) {
                console.error('Error loading font:', error);
                fontStatus.textContent = 'Failed to load custom font: ' + error.message + '. Using default font.';
                preview.style.fontFamily = 'sans-serif';
                updateAllTextBoxes();
            });
        }

        function createTextBox() {
            const id = Date.now().toString();
            const textBox = {
                id: id,
                text: '',
                shape: 'rectangle',
                formatOption: 'default',
                size: 50,
                rotation: 0,
                position: { left: 50, top: 50 },
                color: 'black'
            };
            textBoxes.push(textBox);
            createTextBoxUI(textBox);
            createTextBoxPreview(textBox);
            updateTextBox(textBox);
        }

        function createTextBoxUI(textBox) {
            const container = document.createElement('div');
            container.className = 'text-box-settings';
            container.id = `settings-${textBox.id}`;
            container.innerHTML = `
                <div class="text-box-header">
                    <button class="visibility-toggle" data-id="${textBox.id}">
                        <img src="images/visible.png" alt="Visibility toggle">
                    </button>
                    <button class="remove-text-box" data-id="${textBox.id}">Ã—</button>
                </div>
                <div class="text-box-content">
                    <textarea id="textInput-${textBox.id}" placeholder="Type here..."></textarea>
                    <div class="shape-options-container">
                        <div class="shape-select-container">
                            <select id="shapeSelect-${textBox.id}">
                                <option value="rectangle">Default</option>
                                <option value="circle">Circle</option>
                                <option value="triangle">Triangle</option>
                                <option value="spiral1">Spiral 1</option>
                                <option value="spiral2">Spiral 2</option>
                                <option value="gate">Gate</option>
                            </select>
                        </div>
                        <div class="format-options-container">
                            <select id="formatOptions-${textBox.id}">
                                <option value="default">Default</option>
                            </select>
                        </div>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="sizeSlider-${textBox.id}" class="size-slider" min="5" max="100" value="50">
                    </div>
                    <div class="slider-container">
                        <input type="range" id="rotationDial-${textBox.id}" class="rotation-dial" min="0" max="359" value="0">
                    </div>
                </div>
            `;
            textBoxesContainer.appendChild(container);

            // Add event listeners
            document.getElementById(`textInput-${textBox.id}`).addEventListener('input', () => updateTextBox(textBox));
            document.getElementById(`shapeSelect-${textBox.id}`).addEventListener('change', (e) => {
                textBox.shape = e.target.value;
                updateFormatOptions(textBox);
                updateTextBox(textBox);
            });
            document.getElementById(`formatOptions-${textBox.id}`).addEventListener('change', (e) => {
                textBox.formatOption = e.target.value;
                updateTextBox(textBox);
            });
            document.getElementById(`sizeSlider-${textBox.id}`).addEventListener('input', () => updateTextBox(textBox));
            document.getElementById(`rotationDial-${textBox.id}`).addEventListener('input', () => updateTextBox(textBox));
            
            // Add event listener for remove button
            const removeButton = container.querySelector('.remove-text-box');
            removeButton.addEventListener('click', () => showRemoveLightbox(textBox));

            // Add event listener for visibility toggle
            const visibilityToggle = container.querySelector('.visibility-toggle');
            visibilityToggle.addEventListener('click', () => toggleTextBoxVisibility(textBox));

            updateFormatOptions(textBox);
        }

        function toggleTextBoxVisibility(textBox) {
            const previewElement = document.getElementById(`preview-${textBox.id}`);
            const visibilityToggle = document.querySelector(`.visibility-toggle[data-id="${textBox.id}"] img`);
            
            if (previewElement.style.display === 'none') {
                previewElement.style.display = '';
                visibilityToggle.src = 'images/visible.png';
                visibilityToggle.alt = 'Visible';
            } else {
                previewElement.style.display = 'none';
                visibilityToggle.src = 'images/invisible.png';
                visibilityToggle.alt = 'Invisible';
            }
        }

        function updateFormatOptions(textBox) {
            const formatOptionsSelect = document.getElementById(`formatOptions-${textBox.id}`);
            formatOptionsSelect.innerHTML = ''; // Clear existing options

            let options;
            switch (textBox.shape) {
                case 'triangle':
                    options = [
                        { value: 'skinny', text: 'Skinny' },
                        { value: 'medium', text: 'Medium' },
                        { value: 'fat', text: 'Fat' }
                    ];
                    break;
                case 'circle':
                    options = [
                        { value: 'circumference', text: 'Circumference' },
                        { value: 'area', text: 'Area' }
                    ];
                    break;
                case 'spiral1':
                case 'spiral2':
                    options = [
                        { value: 'compact', text: 'Compact' },
                        { value: 'normal', text: 'Normal' },
                        { value: 'expanded', text: 'Expanded' }
                    ];
                    break;
                case 'gate':
                    options = [
                        { value: 'default', text: 'Default' }
                    ];
                    break;
                default:
                    options = [{ value: 'default', text: 'Default' }];
            }

            options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option.value;
                optionElement.textContent = option.text;
                formatOptionsSelect.appendChild(optionElement);
            });

            textBox.formatOption = options[0].value; // Set default option
        }

        function createTextBoxPreview(textBox) {
            const previewElement = document.createElement('div');
            previewElement.id = `preview-${textBox.id}`;
            previewElement.className = 'preview-text';
            preview.appendChild(previewElement);

            // Add drag functionality
            previewElement.addEventListener('mousedown', (e) => startDragging(e, textBox));
        }

        function updateTextBox(textBox) {
            const previewElement = document.getElementById(`preview-${textBox.id}`);
            const textInput = document.getElementById(`textInput-${textBox.id}`);
            const shapeSelect = document.getElementById(`shapeSelect-${textBox.id}`);
            const formatOptionsSelect = document.getElementById(`formatOptions-${textBox.id}`);
            const sizeSlider = document.getElementById(`sizeSlider-${textBox.id}`);
            const rotationDial = document.getElementById(`rotationDial-${textBox.id}`);

            textBox.text = textInput.value;
            textBox.shape = shapeSelect.value;
            textBox.formatOption = formatOptionsSelect.value;
            textBox.size = parseInt(sizeSlider.value);
            textBox.rotation = parseInt(rotationDial.value);

            previewElement.style.left = `${textBox.position.left}%`;
            previewElement.style.top = `${textBox.position.top}%`;
            previewElement.style.color = textBox.color;
            previewElement.style.transform = `translate(-50%, -50%) rotate(${textBox.rotation}deg)`;

            switch(textBox.shape) {
                case 'rectangle':
                    previewElement.innerHTML = textBox.text || '&nbsp;';
                    previewElement.style.width = 'auto';
                    previewElement.style.height = 'auto';
                    previewElement.style.display = 'flex';
                    previewElement.style.justifyContent = 'center';
                    previewElement.style.alignItems = 'center';
                    break;
                case 'circle':
                    previewElement.innerHTML = createCircleText(textBox.text, textBox.formatOption);
                    if (textBox.formatOption === 'area') {
                        previewElement.style.width = 'auto';
                        previewElement.style.height = 'auto';
                    } else {
                        setShapeSize(previewElement, textBox.size);
                    }
                    break;
                case 'triangle':
                    previewElement.innerHTML = createTriangleText(textBox.text, textBox.formatOption);
                    previewElement.style.width = 'auto';
                    previewElement.style.height = 'auto';
                    previewElement.style.textAlign = 'center';
                    previewElement.style.whiteSpace = 'pre';
                    break;
                case 'spiral1':
                    previewElement.innerHTML = createSpiral1Text(textBox.text, textBox.formatOption);
                    setShapeSize(previewElement, textBox.size);
                    break;
                case 'spiral2':
                    previewElement.innerHTML = createSpiral2Text(textBox.text, textBox.formatOption);
                    setShapeSize(previewElement, textBox.size);
                    break;
                case 'gate':
                    previewElement.innerHTML = createGateText(textBox.text);
                    previewElement.style.width = 'auto';
                    previewElement.style.height = 'auto';
                    break;
            }

            adjustFontSize(previewElement, textBox);
        }

        function setShapeSize(element, size) {
            const sizeValue = `${size}%`;
            element.style.width = sizeValue;
            element.style.height = sizeValue;
        }

        function adjustFontSize(element, textBox) {
            const previewSize = Math.min(preview.clientWidth, preview.clientHeight);
            let minFontSize, maxFontSize;

            switch(textBox.shape) {
                case 'rectangle':
                case 'triangle':
                    minFontSize = 0.5;
                    maxFontSize = 24;
                    break;
                case 'circle':
                    if (textBox.formatOption === 'area') {
                        minFontSize = 0.5;
                        maxFontSize = 3;
                    } else {
                        minFontSize = 0.5;
                        maxFontSize = 16;
                    }
                    break;
                case 'spiral1':
                case 'spiral2':
                    minFontSize = 0.5;
                    maxFontSize = 16;
                    break;
                case 'gate':
                    minFontSize = 0.5;
                    maxFontSize = 2;
                    break;
            }

            const fontSize = minFontSize + (textBox.size / 100) * (maxFontSize - minFontSize);
            
            if (textBox.shape === 'rectangle' || textBox.shape === 'triangle' || textBox.shape === 'gate' || (textBox.shape === 'circle' && textBox.formatOption === 'area')) {
                element.style.fontSize = `${fontSize}vw`;
            } else {
                const chars = Array.from(element.children);
                chars.forEach(char => {
                    char.style.fontSize = `${fontSize}vw`;
                });
            }
        }

        function createCircleText(text, formatOption) {
            if (formatOption === 'circumference') {
                return createCircumferenceText(text);
            } else {
                return createCircleAreaText(text);
            }
        }

        function createCircumferenceText(text) {
            const chars = text.split('');
            const charCount = chars.length;
            const baseRadius = 45;
            const radius = baseRadius + (charCount * 2);

            return chars.map((char, i) => {
                const angle = (i / charCount) * 2 * Math.PI - Math.PI / 2;
                const x = 50 + radius * Math.cos(angle);
                const y = 50 + radius * Math.sin(angle);
                return `<span style="position: absolute; left: ${x}%; top: ${y}%; transform: translate(-50%, -50%) rotate(${angle + Math.PI/2}rad)">${char}</span>`;
            }).join('');
        }

        function createCircleAreaText(text) {
            const chars = text.split('');
            const charCount = chars.length;
            
            // Estimate initial height based on character count
            let height = Math.ceil(Math.sqrt(charCount / (Math.PI * 1.5))); // Adjust for 1.5 aspect ratio
            let width = Math.floor(height * 1.5);
            let result = '';
            let usedChars = 0;

            // Adjust size until all characters are used or we can't fit more
            while (usedChars < charCount) {
                result = '';
                usedChars = 0;
                const verticalRadius = Math.floor(height / 2);
                const horizontalRadius = Math.floor(width / 2);

                for (let y = -verticalRadius; y <= verticalRadius; y++) {
                    let line = '';
                    // Use a quadratic function to create a more circular shape
                    const lineWidth = Math.round(width * (1 - Math.pow(y / verticalRadius, 2)));

                    // Calculate left padding for centering
                    const leftPadding = Math.floor((width - lineWidth) / 2);
                    
                    // Add characters to the line
                    for (let x = 0; x < lineWidth; x++) {
                        if (usedChars < charCount) {
                            line += chars[usedChars++];
                        } else {
                            break;
                        }
                    }

                    if (line.length > 0) {
                        // Center the text within the line
                        const rightPadding = width - leftPadding - line.length;
                        result += `<div style="white-space: pre;">${'&nbsp;'.repeat(leftPadding)}${line}${'&nbsp;'.repeat(rightPadding)}</div>`;
                    } else {
                        result += `<div style="white-space: pre;">${'&nbsp;'.repeat(width)}</div>`;
                    }
                }

                if (usedChars < charCount) {
                    height += 1;
                    width = Math.floor(height * 1.5);
                } else {
                    break; // All characters used, we're done
                }
            }

            return `<div style="display: inline-block; line-height: 1; text-align: center; font-family: p1a;">${result}</div>`;
        }

        function getMaxCharsForLine(lineNumber, baseRadius) {
            // This function calculates the maximum number of characters that can fit on each line
            // to approximate a circular shape. You may need to adjust this formula for better results.
            const maxLineLength = Math.floor(baseRadius * 2);
            const middleLine = Math.ceil(baseRadius);
            const distanceFromMiddle = Math.abs(lineNumber - middleLine);
            return Math.floor(Math.sqrt(maxLineLength * maxLineLength - distanceFromMiddle * distanceFromMiddle));
        }

        function createTriangleText(text, formatOption) {
            let lines = [];
            let currentLine = '';
            let lineNumber = 0;
            let maxLineLength = 0;
            let maxLineChars = 1;  // Start with 1 character for the first line

            const getIncrement = () => {
                switch (formatOption) {
                    case 'skinny': return 1;
                    case 'medium': return 3;
                    case 'fat': return 5;
                    default: return 3;
                }
            };

            const increment = getIncrement();

            for (let char of text) {
                if (currentLine.length < maxLineChars) {
                    currentLine += char;
                } else {
                    lines.push(currentLine);
                    maxLineLength = Math.max(maxLineLength, currentLine.length);
                    currentLine = char;
                    lineNumber++;
                    maxLineChars += increment;
                }
            }

            if (currentLine) {
                lines.push(currentLine);
                maxLineLength = Math.max(maxLineLength, currentLine.length);
            }

            // Center-align each line
            lines = lines.map(line => {
                const padding = maxLineLength - line.length;
                const leftPad = Math.floor(padding / 2);
                const rightPad = padding - leftPad;
                return ' '.repeat(leftPad) + line + ' '.repeat(rightPad);
            });

            return lines.join('\n');
        }

        function createSpiral1Text(text, formatOption) {
            const chars = text.split('');
            const charCount = chars.length;
            let maxRadius, baseAngle;

            switch (formatOption) {
                case 'compact': maxRadius = 40; baseAngle = 0.4; break;
                case 'expanded': maxRadius = 50; baseAngle = 0.6; break;
                default: maxRadius = 45; baseAngle = 0.5;
            }

            const maxSpaces = 10;
            const minSpaces = 1;

            return chars.map((char, i) => {
                const angleDecayFactor = 1 - (i / charCount) * 0.05;
                const angle = i * baseAngle * angleDecayFactor;
                const radiusFactor = 1 + charCount/10;
                const radius = Math.min(maxRadius * radiusFactor, (i / charCount) * maxRadius * radiusFactor);
                const spaceCount = maxSpaces - (i / charCount) * (maxSpaces - minSpaces);
                const spaces = ' '.repeat(Math.max(minSpaces, Math.floor(spaceCount)));
                const x = 50 + radius * Math.cos(angle);
                const y = 50 + radius * Math.sin(angle);
                return `<span style="position: absolute; left: ${x}%; top: ${y}%; transform: translate(-50%, -50%) rotate(${angle + Math.PI/2}rad)">${char}${spaces}</span>`;
            }).join('');
        }

        function createSpiral2Text(text, formatOption) {
            const chars = text.split('');
            const charCount = chars.length;
            let maxRadius, baseAngle;

            switch (formatOption) {
                case 'compact': maxRadius = 40; baseAngle = 0.4; break;
                case 'expanded': maxRadius = 50; baseAngle = 0.6; break;
                default: maxRadius = 45; baseAngle = 0.5;
            }

            const maxSpaces = 10;
            const minSpaces = 1;

            return chars.map((char, i) => {
                const angleDecayFactor = 1 - (i / charCount) * 0.05;
                const angle = i * baseAngle * angleDecayFactor;
                const radiusFactor = 1 + charCount/100;
                const radius = Math.min(maxRadius * radiusFactor, (i / charCount) * maxRadius * radiusFactor);
                const spaceCount = maxSpaces - (i / charCount) * (maxSpaces - minSpaces);
                const spaces = ' '.repeat(Math.max(minSpaces, Math.floor(spaceCount)));
                const x = 50 + radius * Math.cos(angle);
                const y = 50 + radius * Math.sin(angle);
                return `<span style="position: absolute; left: ${x}%; top: ${y}%; transform: translate(-50%, -50%) rotate(${angle + Math.PI/2}rad)">${char}${spaces}</span>`;
            }).join('');
        }

        function createGateText(text) {
            const chars = text.split('');
            const baseRadius = 25; // Adjust this value to change the size of the gate
            let result = '';

            for (let y = -baseRadius; y <= baseRadius; y++) {
                let line = '';
                for (let x = -baseRadius; x <= baseRadius; x++) {
                    const distance = Math.sqrt(x * x + y * y);
                    if (distance < baseRadius && distance > baseRadius - 3) {
                        if (chars.length > 0) {
                            line += chars.shift();
                        } else {
                            line += ' ';
                        }
                    } else if (distance <= baseRadius - 3) {
                        line += ' ';
                    }
                }
                if (line.trim().length > 0) {
                    result += `<div style="white-space: pre; text-align: center;">${line}</div>`;
                }
            }

            return `<div style="display: inline-block; line-height: 1;">${result}</div>`;
        }

        function startDragging(e, textBox) {
            const previewElement = document.getElementById(`preview-${textBox.id}`);
            const rect = preview.getBoundingClientRect();
            const startX = e.clientX - rect.left;
            const startY = e.clientY - rect.top;
            const startLeft = textBox.position.left;
            const startTop = textBox.position.top;

            function drag(e) {
                const newX = e.clientX - rect.left;
                const newY = e.clientY - rect.top;
                const deltaX = newX - startX;
                const deltaY = newY - startY;

                textBox.position.left = Math.max(0, Math.min(100, startLeft + (deltaX / rect.width) * 100));
                textBox.position.top = Math.max(0, Math.min(100, startTop + (deltaY / rect.height) * 100));

                updateTextBox(textBox);
            }

            function stopDragging() {
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', stopDragging);
                preview.style.cursor = 'default';
            }

            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDragging);
            preview.style.cursor = 'grabbing';
        }

        function updateAllTextBoxes() {
            textBoxes.forEach(updateTextBox);
        }

        function preloadImages() {
            backgroundOptions.forEach(option => {
                const imageUrl = option.getAttribute('data-image');
                const img = new Image();
                img.src = imageUrl;
                imageCache.set(imageUrl, img);
                option.style.backgroundImage = `url('${imageUrl}')`;
            });
        }

        function setBackgroundImage(imageUrl) {
            currentBackgroundImage = `url('${imageUrl}')`;
            preview.style.backgroundImage = currentBackgroundImage;
            adjustTextColors();
        }

        function adjustTextColors() {
            const computedStyle = window.getComputedStyle(preview);
            const bgImage = computedStyle.backgroundImage;
            
            if (bgImage && bgImage !== 'none') {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0, img.width, img.height);
                    
                    const imageData = ctx.getImageData(img.width / 2, img.height / 2, 1, 1).data;
                    const brightness = (imageData[0] * 299 + imageData[1] * 587 + imageData[2] * 114) / 1000;
                    
                    const newColor = brightness > 128 ? 'black' : 'white';
                    textBoxes.forEach(textBox => {
                        textBox.color = newColor;
                        updateTextBox(textBox);
                    });
                };
                img.src = bgImage.replace(/url\(['"]?|['"]?\)/g, '');
            } else {
                textBoxes.forEach(textBox => {
                    textBox.color = 'black';
                    updateTextBox(textBox);
                });
            }
        }

        function showRemoveLightbox(textBox) {
            textBoxToRemove = textBox;
            removeLightbox.style.display = 'block';
        }

        function hideRemoveLightbox() {
            removeLightbox.style.display = 'none';
            textBoxToRemove = null;
        }

        function removeTextBox(textBox) {
            const index = textBoxes.findIndex(tb => tb.id === textBox.id);
            if (index !== -1) {
                textBoxes.splice(index, 1);
                const settingsElement = document.getElementById(`settings-${textBox.id}`);
                const previewElement = document.getElementById(`preview-${textBox.id}`);
                settingsElement.remove();
                previewElement.remove();
            }
        }

        addTextBoxButton.addEventListener('click', createTextBox);

        removeLightbox.querySelector('.confirm-remove').addEventListener('click', () => {
            if (textBoxToRemove) {
                removeTextBox(textBoxToRemove);
                hideRemoveLightbox();
            }
        });

        removeLightbox.querySelector('.cancel-remove').addEventListener('click', hideRemoveLightbox);

        backgroundOptions.forEach(option => {
            option.addEventListener('click', function() {
                backgroundOptions.forEach(opt => opt.classList.remove('active'));
                this.classList.add('active');
                const imageUrl = this.getAttribute('data-image');
                setBackgroundImage(imageUrl);
            });
        });

        window.addEventListener('DOMContentLoaded', function() {
            loadCustomFont();
            preloadImages();
            createTextBox(); // Create an initial text box
        });

        window.addEventListener('resize', updateAllTextBoxes);
</script>
</body>
</html>